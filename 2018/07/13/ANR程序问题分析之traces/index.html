<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>ANR程序问题分析之traces | 小麦</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/blog/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-131087828-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ANR程序问题分析之traces</h1><a id="logo" href="/blog/.">小麦</a><p class="description">人生的大起大落来得太突然，搞得我直想尿尿...</p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a><a href="/blog/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ANR程序问题分析之traces</h1><div class="post-meta">2018-07-13<span> | </span><span class="category"><a href="/blog/categories/Android-Framework/">Android Framework</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 5.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 24</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/blog/2018/07/13/ANR%E7%A8%8B%E5%BA%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B9%8Btraces/#vcomment"><span class="valine-comment-count" data-xid="/blog/2018/07/13/ANR%E7%A8%8B%E5%BA%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B9%8Btraces/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#ANR%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF"><span class="toc-number">1.</span> <span class="toc-text">ANR的异常信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ANR%E4%BF%A1%E6%81%AF%E6%98%AF%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA%E7%9A%84"><span class="toc-number">2.</span> <span class="toc-text">ANR信息是如何输出的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90ANR%E7%9A%84trace%E4%BF%A1%E6%81%AF"><span class="toc-number">3.</span> <span class="toc-text">分析ANR的trace信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">4.</span> <span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E4%BD%BF%E7%94%A8%E7%8E%87"><span class="toc-number">5.</span> <span class="toc-text">CPU使用率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E8%B4%9F%E8%BD%BD-%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD"><span class="toc-number">5.1.</span> <span class="toc-text">CPU负载&#x2F;平均负载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ANR%E5%8F%91%E7%94%9F%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84CPU%E4%BD%BF%E7%94%A8%E7%8E%87"><span class="toc-number">5.2.</span> <span class="toc-text">ANR发生之前和之后一段时间的CPU使用率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%9D%A1%E7%9C%A0%E6%97%B6%E9%97%B4%E7%99%BE%E5%88%86%E6%AF%94"><span class="toc-number">5.3.</span> <span class="toc-text">非睡眠时间百分比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%94%99%E8%AF%AF%E6%AC%A1%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">页错误次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E5%92%8C%E7%A7%BB%E9%99%A4%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%88%96%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.5.</span> <span class="toc-text">新增和移除的进程或线程</span></a></li></ol></li></ol></div></div><div class="post-content"><p>每次发生ANR，这个文件都会被清空，写入新的内容。如果想查看以前发生ANR的信息，可以去查看DB文件，<br>也就是DropBox的中的日志<br>跟踪功能，保存历史上发生的所有ANR的日志<br>“/ data / system / dropbox”是DB指定的文件存放位置。<br>日志保存的最长时间，默认是3天</p>
<h3 id="ANR的异常信息"><a href="#ANR的异常信息" class="headerlink" title="ANR的异常信息"></a>ANR的异常信息</h3><p>使用logcat命令查看会得到类似如下的log</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;WindowManager所在的进程是system_server，进程号是127</span><br><span class="line">I&#x2F;WindowManager( 127): Input event dispatching timed out sending to com.example.anrdemo&#x2F;com.example.anrdemo.ANRActivity</span><br><span class="line">&#x2F;&#x2F;system_server进程中的ActivityManagerService请求kernel向5033进程发送SIGNAL_QUIT请求</span><br><span class="line">&#x2F;&#x2F;你可以在shell中使用命令达到相同的目的：adb shell kill -3 5033</span><br><span class="line">&#x2F;&#x2F;和其他的Java虚拟机一样，SIGNAL_QUIT也是Dalvik内部支持的功能之一</span><br><span class="line">I&#x2F;Process ( 127): Sending signal. PID: 5033 SIG: 3</span><br><span class="line">&#x2F;&#x2F;5033进程的虚拟机实例接收到SIGNAL_QUIT信号后会将进程中各个线程的函数堆栈信息输出到traces.txt文件中</span><br><span class="line">&#x2F;&#x2F;发生ANR的进程正常情况下会第一个输出</span><br><span class="line">I&#x2F;dalvikvm( 5033): threadid&#x3D;4: reacting to signal 3</span><br><span class="line">I&#x2F;dalvikvm( 5033): Wrote stack traces to &#39;&#x2F;data&#x2F;anr&#x2F;traces.txt&#39;</span><br><span class="line">... ...&#x2F;&#x2F;另外还有其他一些进程</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;随后会输出CPU使用情况</span><br><span class="line">E&#x2F;ActivityManager( 127): ANR in com.example.anrdemo (com.example.anrdemo&#x2F;.ANRActivity)</span><br><span class="line">&#x2F;&#x2F;Reason表示导致ANR问题的直接原因</span><br><span class="line">E&#x2F;ActivityManager( 127): Reason: keyDispatchingTimedOut</span><br><span class="line">E&#x2F;ActivityManager( 127): Load: 3.85 &#x2F; 3.41 &#x2F; 3.16</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;请注意ago，表示ANR发生之前的一段时间内的CPU使用率，并不是某一时刻的值</span><br><span class="line">E&#x2F;ActivityManager( 127): CPU usage from 26835ms to 3662ms ago with 99% awake:</span><br><span class="line">E&#x2F;ActivityManager( 127): 9.4% 98&#x2F;mediaserver: 9.4% user + 0% kernel</span><br><span class="line">E&#x2F;ActivityManager( 127): 8.9% 127&#x2F;system_server: 6.9% user + 2% kernel &#x2F; faults: 1823 minor</span><br><span class="line">... ...</span><br><span class="line">E&#x2F;ActivityManager( 127): +0% 5033&#x2F;com.example.anrdemo: 0% user + 0% kernel</span><br><span class="line">E&#x2F;ActivityManager( 127): 39% TOTAL: 32% user + 6.1% kernel</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里是later，表示ANR发生之后</span><br><span class="line">E&#x2F;ActivityManager( 127): CPU usage from 601ms to 1132ms later with 99% awake:</span><br><span class="line">E&#x2F;ActivityManager( 127): 10% 127&#x2F;system_server: 1.7% user + 8.9% kernel &#x2F; faults: 5 minor</span><br><span class="line">E&#x2F;ActivityManager( 127): 10% 163&#x2F;InputDispatcher: 1.7% user + 8.9% kernel</span><br><span class="line">E&#x2F;ActivityManager( 127): 1.7% 127&#x2F;system_server: 1.7% user + 0% kernel</span><br><span class="line">E&#x2F;ActivityManager( 127): 1.7% 135&#x2F;SurfaceFlinger: 0% user + 1.7% kernel</span><br><span class="line">E&#x2F;ActivityManager( 127): 1.7% 2814&#x2F;Binder Thread #: 1.7% user + 0% kernel</span><br><span class="line">... ...</span><br><span class="line">E&#x2F;ActivityManager( 127): 37% TOTAL: 27% user + 9.2% kernel</span><br></pre></td></tr></table></figure>
<p>发生ANR时Android为我们提供了两种“利器”：traces文件和CPU使用率</p>
<h3 id="ANR信息是如何输出的"><a href="#ANR信息是如何输出的" class="headerlink" title="ANR信息是如何输出的"></a>ANR信息是如何输出的</h3><p>ActivityManagerService类中，找到它的appNotResponding函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">    final void appNotResponding(ProcessRecord app, ActivityRecord activity,</span><br><span class="line">                                ActivityRecord parent, final String annotation) &#123;</span><br><span class="line">&#x2F;&#x2F;firstPids和lastPids两个集合存放那些将会在traces中输出信息的进程的进程号</span><br><span class="line">        ArrayList&lt;Integer&gt; firstPids &#x3D; new ArrayList&lt;Integer&gt;(5);</span><br><span class="line">        SparseArray&lt;Boolean&gt; lastPids &#x3D; new SparseArray&lt;Boolean&gt;(20);</span><br><span class="line">&#x2F;&#x2F;mController是IActivityController接口的实例，是为Monkey测试程序预留的，默认为null</span><br><span class="line">        if (mController !&#x3D; null) &#123;</span><br><span class="line">... ...</span><br><span class="line">        &#125;</span><br><span class="line">        long anrTime &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">        if (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">            updateCpuStatsNow(); &#x2F;&#x2F;更新CPU使用率</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (this) &#123; &#x2F;&#x2F;一些特定条件下会忽略ANR</span><br><span class="line">            if (mShuttingDown) &#123;</span><br><span class="line">                Slog.i(TAG, &quot;During shutdown skipping ANR: &quot; + app + &quot; &quot; + annotation);</span><br><span class="line">                return;</span><br><span class="line">            &#125; else if (app.notResponding) &#123;</span><br><span class="line">                Slog.i(TAG, &quot;Skipping duplicate ANR: &quot; + app + &quot; &quot; + annotation);</span><br><span class="line">                return;</span><br><span class="line">            &#125; else if (app.crashing) &#123;</span><br><span class="line">                Slog.i(TAG, &quot;Crashing app skipping ANR: &quot; + app + &quot; &quot; + annotation);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;使用一个标志变量避免同一个应用在没有处理完时重复输出log</span><br><span class="line">            app.notResponding &#x3D; true;</span><br><span class="line">... ...</span><br><span class="line">         &#x2F;&#x2F;①当前发生ANR的应用进程被第一个添加进firstPids集合中</span><br><span class="line">            firstPids.add(app.pid);</span><br><span class="line">... ...</span><br><span class="line">        &#125;</span><br><span class="line">... ...</span><br><span class="line">        &#x2F;&#x2F;②dumpStackTraces是输出traces文件的函数</span><br><span class="line">        File tracesFile &#x3D; dumpStackTraces(true, firstPids, processStats, lastPids, null);</span><br><span class="line">        String cpuInfo &#x3D; null;</span><br><span class="line">        if (MONITOR_CPU_USAGE) &#123; &#x2F;&#x2F;MONITOR_CPU_USAGE默认为true</span><br><span class="line">            updateCpuStatsNow(); &#x2F;&#x2F;再次更新CPU信息</span><br><span class="line">            synchronized (mProcessStatsThread) &#123;</span><br><span class="line">                &#x2F;&#x2F;输出ANR发生前一段时间内的CPU使用率</span><br><span class="line">                cpuInfo &#x3D; mProcessStats.printCurrentState(anrTime);</span><br><span class="line">            &#125;</span><br><span class="line">            info.append(processStats.printCurrentLoad());</span><br><span class="line">            info.append(cpuInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;输出ANR发生后一段时间内的CPU使用率</span><br><span class="line">        info.append(processStats.printCurrentState(anrTime));</span><br><span class="line">... ...</span><br><span class="line">        &#x2F;&#x2F;③将ANR信息同时输出到DropBox中</span><br><span class="line">        addErrorToDropBox(&quot;anr&quot;, app, app.processName, activity, parent, annotation,</span><br><span class="line">                cpuInfo, tracesFile, null);</span><br><span class="line">... ...</span><br><span class="line">        &#x2F;&#x2F;在Android4.0中可以设置是否不显示ANR提示对话框，如果设置的话就不会显示对话框，并且会杀掉ANR进程</span><br><span class="line">        boolean showBackground &#x3D; Settings.Secure.getInt(mContext.getContentResolver(),</span><br><span class="line">                Settings.Secure.ANR_SHOW_BACKGROUND, 0) !&#x3D; 0;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (!showBackground &amp;&amp; !app.isInterestingToUserLocked() &amp;&amp; app.pid !&#x3D; MY_PID) &#123;</span><br><span class="line">... ...</span><br><span class="line">                Process.killProcessQuiet(app.pid);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">... ...</span><br><span class="line">            &#x2F;&#x2F; 显示ANR提示对话框</span><br><span class="line">            Message msg &#x3D; Message.obtain();</span><br><span class="line">            HashMap map &#x3D; new HashMap();</span><br><span class="line">            msg.what &#x3D; SHOW_NOT_RESPONDING_MSG;</span><br><span class="line">            msg.obj &#x3D; map;</span><br><span class="line">            map.put(&quot;app&quot;, app);</span><br><span class="line">            if (activity !&#x3D; null) &#123;</span><br><span class="line">                map.put(&quot;activity&quot;, activity);</span><br><span class="line">            &#125;</span><br><span class="line">            mHandler.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当前发生ANR的应用进程被第一个添加进firstPids集合中，所以会第一个向traces文件中写入信息。反过来说，traces文件中出现的第一个进程正常情况下就是发生ANR的那个进程。不过有时候会很不凑巧，发生ANR的进程还没有来得及输出trace信息，就由于某种原因退出了，所以偶尔会遇到traces文件中找不到发生ANR的进程信息的情况。<br>dumpStackTraces是输出traces文件的函数，接下来分析这个函数<br>addErrorToDropBox函数将ANR信息同时输出到DropBox中，它也是个非常有用的日志存放工具，后面也会分析它的作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> public static File dumpStackTraces(boolean clearTraces, ArrayList&lt;Integer&gt; firstPids,</span><br><span class="line">                                       ProcessStats processStats, SparseArray&lt;Boolean&gt; lastPids, String[] nativeProcs) &#123;</span><br><span class="line">&#x2F;&#x2F;系统属性“dalvik.vm.stack-trace-file”用来配置trace信息输出文件</span><br><span class="line">        String tracesPath &#x3D; SystemProperties.get(&quot;dalvik.vm.stack-trace-file&quot;, null);</span><br><span class="line">        if (tracesPath &#x3D;&#x3D; null || tracesPath.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        File tracesFile &#x3D; new File(tracesPath);</span><br><span class="line">        try &#123;</span><br><span class="line">            File tracesDir &#x3D; tracesFile.getParentFile();</span><br><span class="line">            if (!tracesDir.exists()) tracesFile.mkdirs();</span><br><span class="line">&#x2F;&#x2F;FileUtils.setPermissions是个很有用的函数，设置文件属性时经常会用到</span><br><span class="line">            FileUtils.setPermissions(tracesDir.getPath(), 0775, -1, -1); &#x2F;&#x2F; drwxrwxr-x</span><br><span class="line">&#x2F;&#x2F;clearTraces为true，会删除旧文件，创建新文件</span><br><span class="line">            if (clearTraces &amp;&amp; tracesFile.exists()) tracesFile.delete();</span><br><span class="line">            tracesFile.createNewFile();</span><br><span class="line">            FileUtils.setPermissions(tracesFile.getPath(), 0666, -1, -1); &#x2F;&#x2F; -rw-rw-rw-</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Unable to prepare ANR traces file: &quot; + tracesPath, e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;一个重载函数</span><br><span class="line">        dumpStackTraces(tracesPath, firstPids, processStats, lastPids, nativeProcs);</span><br><span class="line">        return tracesFile;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>之所以trace信息会输出到“/data/anr/traces.txt”文件中，就是系统属性“dalvik.vm.stack-trace-file”设置的。你可以通过在设备的shell中使用setprop和getprop对系统属性进行设置和读取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getpropdalvik.vm.stack-trace-file</span><br><span class="line">setprop dalvik.vm.stack-trace-file &#x2F;tmp&#x2F;stack-traces.txt</span><br></pre></td></tr></table></figure>
<p>每次发生ANR时都会删除旧的traces文件，重新创建新文件。也就是说Android只保留最后一次发生ANR时的traces信息，那么以前的traces信息就丢失了么？稍后回答。<br>接着来看重载的dumpStackTraces函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   private static void dumpStackTraces(String tracesPath, ArrayList&lt;Integer&gt; firstPids,</span><br><span class="line">                                        ProcessStats processStats, SparseArray&lt;Boolean&gt; lastPids, String[] nativeProcs) &#123;</span><br><span class="line">&#x2F;&#x2F;使用FileObserver监听应用进程是否已经完成写入traces文件的操作</span><br><span class="line">&#x2F;&#x2F;Android在判断桌面壁纸文件是否设置完成时也是用的FileObserver，很有用的类</span><br><span class="line">        FileObserver observer &#x3D; new FileObserver(tracesPath, FileObserver.CLOSE_WRITE) &#123;</span><br><span class="line">            public synchronized void onEvent(int event, String path) &#123;</span><br><span class="line">                notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">... ...</span><br><span class="line">&#x2F;&#x2F;首先输出firstPids集合中指定的进程，这些也是对ANR问题来说最重要的进程</span><br><span class="line">        if (firstPids !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int num &#x3D; firstPids.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; num; i++) &#123;</span><br><span class="line">                    synchronized (observer) &#123;</span><br><span class="line">&#x2F;&#x2F;前面提到的SIGNAL_QUIT</span><br><span class="line">                        Process.sendSignal(firstPids.get(i), Process.SIGNAL_QUIT);</span><br><span class="line">                        observer.wait(200);</span><br><span class="line">... ...</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析ANR的trace信息"><a href="#分析ANR的trace信息" class="headerlink" title="分析ANR的trace信息"></a>分析ANR的trace信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;文件中输出的第一个进程的trace信息，正是发生ANR的演示程序</span><br><span class="line">&#x2F;&#x2F;开头显示进程号、ANR发生的时间点和进程名称</span><br><span class="line">----- pid 9183 at 2012-09-28 22:20:42 -----</span><br><span class="line">Cmd line: com.example.anrdemo</span><br><span class="line"> </span><br><span class="line">DALVIK THREADS: &#x2F;&#x2F;以下是各个线程的函数堆栈信息</span><br><span class="line">&#x2F;&#x2F;mutexes表示虚拟机实例中各种线程相关对象锁的value值</span><br><span class="line">(mutexes: tll&#x3D;0 tsl&#x3D;0 tscl&#x3D;0 ghl&#x3D;0 hwl&#x3D;0 hwll&#x3D;0)</span><br><span class="line">&#x2F;&#x2F;依次是：线程名、线程优先级、线程创建时的序号、①线程当前状态</span><br><span class="line">&quot;main&quot; prio&#x3D;5 tid&#x3D;1 TIMED_WAIT</span><br><span class="line">&#x2F;&#x2F;依次是：线程组名称、suspendCount、debugSuspendCount、线程的Java对象地址、线程的Native对象地址</span><br><span class="line">| group&#x3D;&quot;main&quot; sCount&#x3D;1 dsCount&#x3D;0 obj&#x3D;0x4025b1b8 self&#x3D;0xce68</span><br><span class="line">&#x2F;&#x2F;sysTid是线程号，主线程的线程号和进程号相同</span><br><span class="line">| sysTid&#x3D;9183 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;-1345002368</span><br><span class="line">| schedstat&#x3D;( 140838632 210998525 213 )</span><br><span class="line">at java.lang.VMThread.sleep(Native Method)</span><br><span class="line">at java.lang.Thread.sleep(Thread.java:1213)</span><br><span class="line">at java.lang.Thread.sleep(Thread.java:1195)</span><br><span class="line">at com.example.anrdemo.ANRActivity.makeANR(ANRActivity.java:44)</span><br><span class="line">at com.example.anrdemo.ANRActivity.onClick(ANRActivity.java:38)</span><br><span class="line">at android.view.View.performClick(View.java:2486)</span><br><span class="line">at android.view.View$PerformClick.run(View.java:9130)</span><br><span class="line">at android.os.Handler.handleCallback(Handler.java:587)</span><br><span class="line">at android.os.Handler.dispatchMessage(Handler.java:92)</span><br><span class="line">at android.os.Looper.loop(Looper.java:130)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:3703)</span><br><span class="line">at java.lang.reflect.Method.invokeNative(Native Method)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:507)</span><br><span class="line">at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:841)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:599)</span><br><span class="line">at dalvik.system.NativeStart.main(Native Method)</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;②Binder线程是进程的线程池中用来处理binder请求的线程</span><br><span class="line">&quot;Binder Thread #2&quot; prio&#x3D;5 tid&#x3D;8 NATIVE</span><br><span class="line">| group&#x3D;&quot;main&quot; sCount&#x3D;1 dsCount&#x3D;0 obj&#x3D;0x40750b90 self&#x3D;0x1440b8</span><br><span class="line">| sysTid&#x3D;9190 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;1476256</span><br><span class="line">| schedstat&#x3D;( 915528 18463135 4 )</span><br><span class="line">at dalvik.system.NativeStart.run(Native Method)</span><br><span class="line"> </span><br><span class="line">&quot;Binder Thread #1&quot; prio&#x3D;5 tid&#x3D;7 NATIVE</span><br><span class="line">| group&#x3D;&quot;main&quot; sCount&#x3D;1 dsCount&#x3D;0 obj&#x3D;0x4074f848 self&#x3D;0x78d40</span><br><span class="line">| sysTid&#x3D;9189 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;1308088</span><br><span class="line">| schedstat&#x3D;( 3509523 25543212 10 )</span><br><span class="line">at dalvik.system.NativeStart.run(Native Method)</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;线程名称后面标识有daemon，说明这是个守护线程</span><br><span class="line">&quot;Compiler&quot; daemon prio&#x3D;5 tid&#x3D;6 VMWAIT</span><br><span class="line">| group&#x3D;&quot;system&quot; sCount&#x3D;1 dsCount&#x3D;0 obj&#x3D;0x4074b928 self&#x3D;0x141e78</span><br><span class="line">| sysTid&#x3D;9188 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;1506000</span><br><span class="line">| schedstat&#x3D;( 21606438 21636964 101 )</span><br><span class="line">at dalvik.system.NativeStart.run(Native Method)</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;JDWP线程是支持虚拟机调试的线程，不需要关心</span><br><span class="line">&quot;JDWP&quot; daemon prio&#x3D;5 tid&#x3D;5 VMWAIT</span><br><span class="line">| group&#x3D;&quot;system&quot; sCount&#x3D;1 dsCount&#x3D;0 obj&#x3D;0x4074b878 self&#x3D;0x16c958</span><br><span class="line">| sysTid&#x3D;9187 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;1510224</span><br><span class="line">| schedstat&#x3D;( 366211 2807617 7 )</span><br><span class="line">at dalvik.system.NativeStart.run(Native Method)</span><br><span class="line">&#x2F;&#x2F;“Signal Catcher”负责接收和处理kernel发送的各种信号，例如SIGNAL_QUIT、SIGNAL_USR1等就是被该线程</span><br><span class="line">&#x2F;&#x2F;接收到，这个文件的内容就是由该线程负责输出的，可以看到它的状态是RUNNABLE，不过此线程也不需要关心</span><br><span class="line">&quot;Signal Catcher&quot; daemon prio&#x3D;5 tid&#x3D;4 RUNNABLE</span><br><span class="line">| group&#x3D;&quot;system&quot; sCount&#x3D;0 dsCount&#x3D;0 obj&#x3D;0x4074b7b8 self&#x3D;0x150008</span><br><span class="line">| sysTid&#x3D;9186 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;1501664</span><br><span class="line">| schedstat&#x3D;( 1708985 6286621 9 )</span><br><span class="line">at dalvik.system.NativeStart.run(Native Method)</span><br><span class="line"> </span><br><span class="line">&quot;GC&quot; daemon prio&#x3D;5 tid&#x3D;3 VMWAIT</span><br><span class="line">| group&#x3D;&quot;system&quot; sCount&#x3D;1 dsCount&#x3D;0 obj&#x3D;0x4074b710 self&#x3D;0x168010</span><br><span class="line">| sysTid&#x3D;9185 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;1503184</span><br><span class="line">| schedstat&#x3D;( 305176 4821778 2 )</span><br><span class="line">at dalvik.system.NativeStart.run(Native Method)</span><br><span class="line"> </span><br><span class="line">&quot;HeapWorker&quot; daemon prio&#x3D;5 tid&#x3D;2 VMWAIT</span><br><span class="line">| group&#x3D;&quot;system&quot; sCount&#x3D;1 dsCount&#x3D;0 obj&#x3D;0x4074b658 self&#x3D;0x16a080</span><br><span class="line">| sysTid&#x3D;9184 nice&#x3D;0 sched&#x3D;0&#x2F;0 cgrp&#x3D;default handle&#x3D;550856</span><br><span class="line">| schedstat&#x3D;( 33691407 26336669 15 )</span><br><span class="line">at dalvik.system.NativeStart.run(Native Method)</span><br><span class="line"> </span><br><span class="line">----- end 9183 -----</span><br><span class="line"> </span><br><span class="line">----- pid 127 at 2012-09-28 22:20:42 -----</span><br><span class="line">Cmd line: system_server</span><br><span class="line">... ...</span><br><span class="line">&#x2F;&#x2F;省略其他进程的信息</span><br></pre></td></tr></table></figure>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><table>
<thead>
<tr>
<th>Thread.java中定义的状态</th>
<th>Thread.cpp中定义的状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TERMINATED</td>
<td>ZOMBIE</td>
<td>线程死亡，终止运行</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>RUNNING/RUNNABLE</td>
<td>线程可运行或正在运行</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>TIMED_WAIT</td>
<td>执行了带有超时参数的wait、sleep或join函数</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>MONITOR</td>
<td>线程阻塞，等待获取对象锁</td>
</tr>
<tr>
<td>WAITING</td>
<td>WAIT</td>
<td>执行了无超时参数的wait函数</td>
</tr>
<tr>
<td>NEW</td>
<td>INITIALIZING</td>
<td>新建，正在初始化，为其分配资源</td>
</tr>
<tr>
<td>NEW</td>
<td>STARTING</td>
<td>新建，正在启动</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>NATIVE</td>
<td>正在执行JNI本地函数</td>
</tr>
<tr>
<td>WAITING</td>
<td>VMWAIT</td>
<td>正在等待VM资源</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>SUSPENDED</td>
<td>线程暂停，通常是由于GC或debug被暂停</td>
</tr>
<tr>
<td></td>
<td>UNKNOWN</td>
<td>未知状态</td>
</tr>
<tr>
<td>Thread.java中的状态和Thread.cpp中的状态是有对应关系的。可以看到前者更加概括，也比较容易理解，面向Java的使用者；而后者更详细，面向虚拟机内部的环境。traces.txt中显示的线程状态都是Thread.cpp中定义的。另外，所有的线程都是遵循POSIX标准的本地线程。关于线程更多的说明可以查阅源码/dalvik/vm/Thread.cpp中的说明。<!-- 线程的ThreadGroup最好也写进去 --></td>
<td></td>
<td></td>
</tr>
<tr>
<td>traces.txt文件中的这些信息是由每个Dalvik进程的SignalCatcher线程输出的，相关代码可以查看/dalvik/vm/目录下的SignalCatcher.cpp::logThreadStacks函数和Thread.cpp:: dvmDumpAllThreadsEx函数。另外请注意，输出堆栈信息时SignalCatcher会暂停所有线程。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>通过该文件很容易就能知道问题进程的主线程发生ANR时正在执行怎样的操作。例如上述示例， ANRActivity在makeANR函数中执行线程sleep时发生ANR，可以推测sleep时间过长，超过了超时上限导致。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="CPU使用率"><a href="#CPU使用率" class="headerlink" title="CPU使用率"></a>CPU使用率</h3><p>内容读取自/proc/stat</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">E&#x2F;ActivityManager( 127): ANR in com.example.anrdemo (com.example.anrdemo&#x2F;.ANRActivity)</span><br><span class="line">E&#x2F;ActivityManager( 127): Reason: keyDispatchingTimedOut</span><br><span class="line">E&#x2F;ActivityManager( 127): Load: 3.85 &#x2F; 3.41 &#x2F; 3.16 &#x2F;&#x2F;➀ CPU平均负载</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;②ANR发生之前的一段时间内的CPU使用率</span><br><span class="line">E&#x2F;ActivityManager( 127): CPU usage from 26835ms to 3662ms ago with 99% awake:&#x2F;&#x2F;③</span><br><span class="line">E&#x2F;ActivityManager( 127): 9.4% 98&#x2F;mediaserver: 9.4% user + 0% kernel</span><br><span class="line">E&#x2F;ActivityManager( 127): 8.9% 127&#x2F;system_server: 6.9% user + 2% kernel &#x2F; faults: 1823 minor &#x2F;&#x2F;⑤ minor或者major的页错误次数</span><br><span class="line">... ...</span><br><span class="line">E&#x2F;ActivityManager( 127):&#x2F;&#x2F;⑥+0% 5033&#x2F;com.example.anrdemo: 0% user + 0% kernel</span><br><span class="line">E&#x2F;ActivityManager( 127): 39% TOTAL: 32% user + 6.1% kernel</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;⑦ANR发生之后的一段时间内的CPU使用率</span><br><span class="line">E&#x2F;ActivityManager( 127): CPU usage from 601ms to 1132ms later with 99% awake:</span><br><span class="line">E&#x2F;ActivityManager( 127): 10% 127&#x2F;system_server: 1.7% user + 8.9% kernel &#x2F; faults: 5 minor</span><br><span class="line">E&#x2F;ActivityManager( 127): 10% 163&#x2F;InputDispatcher: 1.7% user + 8.9% kernel</span><br><span class="line">E&#x2F;ActivityManager( 127): 1.7% 127&#x2F;system_server: 1.7% user + 0% kernel</span><br><span class="line">E&#x2F;ActivityManager( 127): 1.7% 135&#x2F;SurfaceFlinger: 0% user + 1.7% kernel</span><br><span class="line">E&#x2F;ActivityManager( 127): 1.7% 2814&#x2F;Binder Thread #: 1.7% user + 0% kernel</span><br><span class="line">... ...</span><br><span class="line">E&#x2F;ActivityManager( 127): 37% TOTAL: 27% user + 9.2% kernel</span><br></pre></td></tr></table></figure>
<h4 id="CPU负载-平均负载"><a href="#CPU负载-平均负载" class="headerlink" title="CPU负载/平均负载"></a>CPU负载/平均负载</h4><p>CPU负载是指某一时刻系统中运行队列长度之和加上当前正在CPU上运行的进程数，而CPU平均负载可以理解为一段时间内正在使用和等待使用CPU的活动进程的平均数量。在Linux中“活动进程”是指当前状态为运行或不可中断阻塞的进程。通常所说的负载其实就是指平均负载。<br>用一个从网上看到的很生动的例子来说明（不考虑CPU时间片的限制），把设备中的一个单核CPU比作一个电话亭，把进程比作正在使用和等待使用电话的人，假如有一个人正在打电话，有三个人在排队等待，此刻电话亭的负载就是4。使用中会不断的有人打完电话离开，也会不断的有其他人排队等待，为了得到一个有参考价值的负载值，可以规定每隔5秒记录一下电话亭的负载，并将某一时刻之前的一分钟、五分钟、十五分钟的的负载情况分别求平均值，最终就得到了三个时段的平均负载。<br>实际上我们通常关心的就是在某一时刻的前一分钟、五分钟、十五分钟的CPU平均负载，例如以上日志中这三个值分别是3.85、3.41、3.16，说明前一分钟内正在使用和等待使用CPU的活动进程平均有3.85个，依此类推。在大型服务器端应用中主要关注的是第五分钟和第十五分钟的两个值，但是Android主要应用在便携手持设备中，有特殊的软硬件环境和应用场景，短时间内的系统的较高负载就有可能造成ANR，所以笔者认为一分钟内的平均负载相对来说更具有参考价值。<br>CPU的负载和使用率没有必然关系，有可能只有一个进程在使用CPU，但执行的是复杂的操作；也有可能等待和正在使用CPU的进程很多，但每个进程执行的都是简单操作。<br>实际处理问题时偶尔会遇到由于平均负载高引起的ANR，典型的特征就是系统中应用进程数量多，CPU总使用率较高，但是每个进程的CPU使用率不高，当前应用进程主线程没有异常阻塞，一分钟内的CPU平均负载较高。</p>
<blockquote>
<p>提示：Linux内核不断进行着CPU负载的记录，我们可以在任意时刻通过在shell中执行“cat /proc/loadavg”查看。</p>
</blockquote>
<h4 id="ANR发生之前和之后一段时间的CPU使用率"><a href="#ANR发生之前和之后一段时间的CPU使用率" class="headerlink" title="ANR发生之前和之后一段时间的CPU使用率"></a>ANR发生之前和之后一段时间的CPU使用率</h4><p>CPU使用率可以理解为一段时间（记作T）内除CPU空闲时间（记作I）之外的时间与这段时间T的比值，用公式表示可以写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU使用率&#x3D; (T – I) &#x2F; T</span><br></pre></td></tr></table></figure>
<p>而时间段T是两个采样时间点的时间差值。<br>之所以可以这样计算，是因为Linux内核会把从系统启动开始到当前时刻CPU活动的所有时间信息都记录下来，我们可以通过查看“/proc/stat”文件获取这些信息。主要包括以下几种时间，这些时间都是从系统启动开始计算的，单位都是0.01秒：</p>
<ul>
<li>user： CPU在用户态的运行时间，不包括nice值为负数的进程运行的时间</li>
<li>nice： CPU在用户态并且nice值为负数的进程运行的时间</li>
<li>system：CPU在内核态运行的时间</li>
<li>idle： CPU空闲时间，不包括iowait时间</li>
<li>iowait： CPU等待I/O操作的时间</li>
<li>irq： CPU硬中断的时间</li>
<li>softirq：CPU软中断的时间</li>
</ul>
<blockquote>
<p>注意：随着Linux内核版本的不同，包含的时间类型有可能不同,Android源码只需要关心以上七种类型即可</p>
</blockquote>
<p>CPU使用率的计算是在ProcessStats类中实现的。如果在某两个时刻T1和T2（T1 &lt; T2）进行采样记录，CPU使用率的整个算法可以归纳为以下几个公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">userTime &#x3D; (user2 + nice2) – (user1 + nice1)</span><br><span class="line">systemTime &#x3D; system2 - system1</span><br><span class="line">idleTime &#x3D; idle2 - idle1</span><br><span class="line">iowaitTime &#x3D; iowait2 - iowait1</span><br><span class="line">irqTime &#x3D; irq2 - irq1</span><br><span class="line">softirqTime &#x3D; softirq2 - softirq1</span><br><span class="line">TotalTime &#x3D; userTime + systemTime + idleTime + iowaitTime + irqTime + softirqTime</span><br></pre></td></tr></table></figure>
<p>有了以上数据就可以计算具体的使用率了，例如用户态CPU使用率为：<br><code>userCpuUsage = userTime / TotalTime</code><br>依此类推可以计算其他类型的使用率。而整个时间段内CPU使用率为：<br><code>CpuUsage = (TotalTime – idleTime) / TotalTime</code><br>以上计算的是整个系统的CPU使用率，对于指定进程的使用率是通过读取该进程的“/proc/进程号/stat”文件计算的，而对于指定进程的指定线程的使用率是通过读取该线程的“/proc/进程号/task/线程号/stat”文件计算的。进程和线程的CPU使用率只包含该进程或线程的总使用率、用户态使用率和内核态使用率。<br>AMS在执行appNotResponding函数过程中，共输出了两个时间段的CPU使用率，通常情况下在ANR发生时间点之前和之后各有一段。两段使用率都是两次调用ProcessStats对象的update函数，每次调用update函数时会保留上一时间点的采样数据，并记录当前时间点的采样数据。然后再调用ProcessStats对象的printCurrentState函数<br>代码位置ActivityManagerService.java → appNotResponding</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    &#x2F;&#x2F;第一次使用成员变量mProcessStats采样</span><br><span class="line">if(MONITOR_CPU_USAGE)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        updateCpuStatsNow();</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    &#x2F;&#x2F;声明了一个局部变量，参数true表示包括线程信息</span><br><span class="line">    final ProcessStats processStats &#x3D; new ProcessStats(true);</span><br><span class="line">    &#x2F;&#x2F;将processStats作为实参传入，在dumpStackTraces中相隔500毫秒两次调用其update函数进行采样</span><br><span class="line">    File tracesFile &#x3D; dumpStackTraces(true, firstPids, processStats, lastPids);</span><br><span class="line">    String cpuInfo &#x3D; null;</span><br><span class="line">if(MONITOR_CPU_USAGE)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">&#x2F;&#x2F;因为在第一次调用后，可能由于输出trace信息等操作，中间执行了较长的时间，所以有第二次使用成员变量</span><br><span class="line">&#x2F;&#x2F;mProcessStats采样，尽量使得采样时间点靠后。</span><br><span class="line">&#x2F;&#x2F;此函数中要求连续两次采样时间间隔不少于5秒，所以一般不会执行第二次采样。一旦执行，就会出现两个采样</span><br><span class="line">&#x2F;&#x2F;时间点一个在ANR发生之前，另一个在其之后，或者两个时间点都在ANR发生之后的情况。</span><br><span class="line">        updateCpuStatsNow();</span><br><span class="line">        synchronized (mProcessStatsThread) &#123;</span><br><span class="line">&#x2F;&#x2F;mProcessStats是成员变量，创建对象时传入的参数是false，所以不包括线程信息</span><br><span class="line">&#x2F;&#x2F;此处先输出ANR发生之前一段时间内的CPU使用率</span><br><span class="line">            cpuInfo &#x3D; mProcessStats.printCurrentState(anrTime);</span><br><span class="line">        &#125;</span><br><span class="line">        info.append(processStats.printCurrentLoad());</span><br><span class="line">        info.append(cpuInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;processStats对象是在ANR发生后创建并采样的，所以输出的是ANR发生之后一段时间内的CPU使用率</span><br><span class="line">info.append(processStats.printCurrentState(anrTime));</span><br></pre></td></tr></table></figure>
<h4 id="非睡眠时间百分比"><a href="#非睡眠时间百分比" class="headerlink" title="非睡眠时间百分比"></a>非睡眠时间百分比</h4><p>在记录CPU使用率的每个采样时间点时使用了两种记录方法：SystemClock.uptimeMillis()和SystemClock.elapsedRealtime()，两者的区别就是uptimeMillis不包含睡眠时间，所以两个采样时间点之间的uptimeMillis和elapsedRealtime之比就是非睡眠时间百分比。</p>
<h4 id="页错误次数"><a href="#页错误次数" class="headerlink" title="页错误次数"></a>页错误次数</h4><p>进程的CPU使用率最后输出的“faults: xxx minor/major”部分表示的是页错误次数，当次数为0时不显示。major是指Major Page Fault（主要页错误，简称MPF），内核在读取数据时会先后查找CPU的高速缓存和物理内存，如果找不到会发出一个MPF信息，请求将数据加载到内存。Minor是指Minor Page Fault（次要页错误，简称MnPF），磁盘数据被加载到内存后，内核再次读取时，会发出一个MnPF信息。一个文件第一次被读写时会有很多的MPF，被缓存到内存后再次访问MPF就会很少，MnPF反而变多，这是内核为减少效率低下的磁盘I/O操作采用的缓存技术的结果。</p>
<p>如果ANR发生时发现CPU使用率中iowait占比很高，可以通过查看进程的major次数来推断是哪个进程在进行磁盘I/O操作。<!-- 求证一下 --></p>
<h4 id="新增和移除的进程或线程"><a href="#新增和移除的进程或线程" class="headerlink" title="新增和移除的进程或线程"></a>新增和移除的进程或线程</h4><p>如果一个进程或线程的CPU使用率前有“+”，说明该进程或线程是在最后两次CPU使用率采样时间段内新建的；反之如果是“-”，说明该进程或线程在采样时间段内终止了；如果是空，说明该进程或线程是在倒数第二次采样时间点之前已经存在。</p>
</div><script type="text/javascript" src="/blog/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://xmaihh.github.io/blog/2018/07/13/ANR%E7%A8%8B%E5%BA%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B9%8Btraces/" data-id="cklj62h4a0009tnsv17wc7a55" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAEOCAAAAABd2qZ5AAAD9ElEQVR42u3bS47bQAwFQN//0sl2gEDWe2RLSYDyyrClVnd5weFnPp/49evH689Pfn5+9e3VlVfrX11z9f5qh58nXjhw4MCBIz7q96Xb4yWUyU6+r98+8WZ9HDhw4MBxiCM/UnuMPCgmB2i/zc+IAwcOHDj+FsfskyQ0bsJkvj4OHDhw4Pg3OTZkSXUuLxq2xUQcOHDgwPEOxyyMbbaeJ2AJ7rHiJg4cOHDgONMnGgat/+X9I/MdOHDgwIGjnApLXkkq2AbaPAznoTQ6Cw4cOHDgOHSWTQvne9Ftkywl3MnKdSKHAwcOHDgWHLNRg7qRE2w9L022gTMvNeLAgQMHjj3HpqDWtqmSgyXbbZ9V7xMHDhw4cKw5koD6TqqWP2uGWwxe4MCBAweOoxyzb/MGVXKAWZuqLXdGiRwOHDhw4Cg5NmMK7b1tOa8lztPLm+QNBw4cOHCMONomTXvUTXK4bzjle7scaMCBAwcOHCOOU8fOB9qSllIe8vOE7SYM48CBAweONcdzobQtzM3SubY4OBxowIEDBw4cMUfygPbYSSo1G2Voh/DqEI4DBw4cOB7jSGhmAwqzxKwtC0Z/WeSBFgcOHDhwlBxtoS1vEeXFwdmx8+dGq+HAgQMHjkMd/yRAtsG1bR3tiWfr1yVCHDhw4MBRZi55q2bzbdvlacNnu0L9C+DAgQMHjiCSzkpsmxmKWaNoNqxQJ6U4cODAgWPBkTd+9knXZv2cphhiSJpPOHDgwIEj5kjKbfmxZwE1Ofa+iBk9BQcOHDhwrDm+Zy55mS9fJwnnLW6yMg4cOHDgeJPj7INPXbNJ5GZX4sCBAweOsxz5UEKx9CKQ70Ny8vTaGwcOHDhwlBxJC6fd6GzN5AfbX4kDBw4cOJ7jaMNbkuzlwTgn2/xBEA1b4MCBAweOBcc+BM6O1N6blyxXTTIcOHDgwHGIox1KS7Y7C89n08K2fYUDBw4cOM5y1DevG0KbINqOYkRhGAcOHDhwrDna4mA7yjALlvm9+zVx4MCBA8dZjjY1ykflknDbjjvkpcDhwBwOHDhw4DjE0aZtybbywDwr/7Xvox8JBw4cOHCsOfKULC/JtSMFeVA8G24v78KBAwcOHAuOWdEtH3fLA3B+vCSxzNf/tJEfBw4cOHDcTyMUYa8dFNgnXfvEsg3bOHDgwIFjz7EZDpgNNOTTFi36PpDjwIEDB45THG1K1t47y5LyFWbFx8tAiwMHDhw4XuGYDaK1Cd6+yJgkgTcpHA4cOHDgeIUjL721LavNYERbTLzZDw4cOHDgOMQxK+RtBhqea3HlAX7VdsKBAwcOHPPYN/zH0VkY/r65dlRuM+6AAwcOHDhKjt+HrHN1yR/gOAAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/blog/tags/Android/"><i class="fa fa-tag"></i>Android</a></div><div class="post-nav"><a class="pre" href="/blog/2018/07/14/ANR%E7%A8%8B%E5%BA%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B9%8Bdropbox/">ANR程序问题分析之dropbox</a><a class="next" href="/blog/2018/07/12/ANR%E7%A8%8B%E5%BA%8F%E6%97%A0%E5%93%8D%E5%BA%94%E7%AE%80%E4%BB%8B/">ANR程序无响应简介</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'ncycqYiwBC0WPXrXqROLBhpf-gzGzoHsz',
  appKey:'2xrqDbFCh3xnfMGAYJBisfAT',
  placeholder:'Just so so',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Android-Framework/">Android Framework</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Flutter/">Flutter</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Raspberry-Pi/">Raspberry Pi</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/SDK%E5%BC%80%E5%8F%91/">SDK开发</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/Android/" style="font-size: 15px;">Android</a> <a href="/blog/tags/ADB/" style="font-size: 15px;">ADB</a> <a href="/blog/tags/BLE/" style="font-size: 15px;">BLE</a> <a href="/blog/tags/Lottie/" style="font-size: 15px;">Lottie</a> <a href="/blog/tags/AndroidStudio/" style="font-size: 15px;">AndroidStudio</a> <a href="/blog/tags/SDK/" style="font-size: 15px;">SDK</a> <a href="/blog/tags/Jni/" style="font-size: 15px;">Jni</a> <a href="/blog/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/blog/tags/Archlinux/" style="font-size: 15px;">Archlinux</a> <a href="/blog/tags/Debian/" style="font-size: 15px;">Debian</a> <a href="/blog/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/blog/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/blog/tags/Java/" style="font-size: 15px;">Java</a> <a href="/blog/tags/Camera/" style="font-size: 15px;">Camera</a> <a href="/blog/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/blog/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/blog/tags/ArchLinux/" style="font-size: 15px;">ArchLinux</a> <a href="/blog/tags/Python/" style="font-size: 15px;">Python</a> <a href="/blog/tags/Ubuntu/" style="font-size: 15px;">Ubuntu</a> <a href="/blog/tags/Gdrive/" style="font-size: 15px;">Gdrive</a> <a href="/blog/tags/ZeroTier/" style="font-size: 15px;">ZeroTier</a> <a href="/blog/tags/Git/" style="font-size: 15px;">Git</a> <a href="/blog/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/blog/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">微信小程序</a> <a href="/blog/tags/Raspberry-Pi/" style="font-size: 15px;">Raspberry Pi</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2019/12/26/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E7%9A%84Android%E6%A8%A1%E6%8B%9F%E5%99%A8/">远程连接局域网内的Android模拟器</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/12/24/%E4%BD%BF%E7%94%A8Kotlin%E7%BC%96%E5%86%99Android%E8%87%AA%E5%AE%9A%E4%B9%89View/">使用Kotlin编写Android自定义View</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/12/11/Java%E4%B8%ADdouble%E8%BD%ACint%E7%B1%BB%E5%9E%8B%E6%8C%89%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E5%8F%96%E6%95%B4/">Java中double转int类型按四舍五入取整</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/11/05/Java%E4%BD%8D%E8%BF%90%E7%AE%97(%E7%A7%BB%E4%BD%8D%E3%80%81%E4%B8%8E%E3%80%81%E6%88%96%E3%80%81%E5%BC%82%E6%88%96%E3%80%81%E9%9D%9E)/">Java位运算(移位、与、或、异或、非)</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/10/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E5%AE%A1%E6%A0%B8/">小程序开发的内容安全审核</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/10/13/Flutter%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E5%92%8C%E4%BC%A0%E5%80%BC/">Flutter开发中的页面跳转和传值</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/17/%E6%A0%91%E8%8E%93%E6%B4%BE4-Ubuntu18.04.2LTS%E4%B8%8B%E9%85%8D%E7%BD%AEWiFi%E4%B8%8ESSH%E8%BF%9E%E6%8E%A5/">树莓派4-Ubuntu18.04.2LTS下配置WiFi与SSH连接</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/07/31/AndroidStudio%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90jni%E5%A4%B4%E6%96%87%E4%BB%B6/">AndroidStudio快速生成jni头文件</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/07/30/Android%E5%BD%95%E9%9F%B3/">Android录音</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/07/19/Ubuntu18-04-2LTS%E4%B8%8BWireshark%E6%8A%A5%E9%94%99Permission-denied/">Ubuntu18.04.2LTS下Wireshark报错Permission denied</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://quincyJiang.github.io" title="瘟疫青年" target="_blank">瘟疫青年</a><ul></ul><a href="https://github.com/xmaihh" title="github" target="_blank">github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/blog/." rel="nofollow">小麦.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/blog/css/search.css?v=1.0.0"><script type="text/javascript" src="/blog/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/blog/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=1.0.0"></script></div></body></html>